<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>补码设计思路的探索</title>
    <url>/2020/08/01/%E8%A1%A5%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%9A%84%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为19级某位大佬提出了<code>补码的存在意义</code>这个问题，回想了一下在初次接触补码时自己对这个问题的思考只停留在了<code>去除了重复的0以及方便了相反数相加得到0</code>这一点上，却没有进一步思考为什么会有这样的需求，遂谷歌后从 <a href="https://stackoverflow.com/questions/1125304/why-prefer-twos-complement-over-sign-and-magnitude-for-signed-numbers">stackoverflow上的相关问题</a> 处得到了较为完备的答案：<strong><code>为了降低加法器电路的复杂度，具体来说就是免除了重复的0的判断以及使用加法电路来同时实现加减法</code></strong>。</p>
<p>然而，这也不禁让我开始好奇起当初补码的设计者们是怎样从这样的需求出发，并最终出这么一套精妙的编码系统的。</p>
<p>我一直坚信，要想把一套知识体系真正消化透彻，其中最为重要而往往也是最为困难的一步就是要去理解这套体系的设计者是如何把它设计出来的。换句话说，就是要尝试去理解这个体系的设计者的设计思路。(在这里偷偷安利一下<a href="https://book.douban.com/subject/30280001/">Computer Networking: A Top-Down Approach</a>这本教材，我特别喜欢这本书在讲解TCP协议时根据需求的升级一步步改进设计方案的讲解思路，能更好地帮助学习者理解协议中引入的每个变量的意义)虽说在面对一些复杂而又精妙的体系时，往往凭着我这榆木脑袋是怎么也想不出个所以然来，但我还是希望尽力地去理解这背后奥妙。</p>
<p>废话不多说，现在就试着来理解补码的设计者的设计思路吧。简洁起见，下面只讨论用补码表示整数以及机器数的位数 n=8 的情况。</p>
<h2 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h2><h3 id="明确任务"><a href="#明确任务" class="headerlink" title="明确任务"></a>明确任务</h3><p>正如在第一段所说，在设计补码之前，我们面对的是<code>消去重复的0</code>以及<code>用同一套简单电路同时实现加减法</code>这两个需求。但其实第一个需求还可以延申一下，变成<code>没有两个不同的码点用于表示同一个值</code>。</p>
<p>所谓编码，其实就是给每一个机器中表示的码点人为地赋上一个意义而已，因此，我们现在的任务就可以用如下的数学语言来描述：</p>
<blockquote>
<p>设 $C={ 0, 1, 2, …, 2^n-2, 2^n-1 }$，即n位机器数的所有码点所构成的集合。设 $V$ 为整数集 $\mathbb{Z}$ 的一个基数为 $2^n$ 的同时包含了 0、正数、负数 的子集，它是我们编码后码点集所能表示的所有整数。</p>
<p>现要求一个定义在 $C$ 上具有封闭性、结合律、交换律的运算 $\oplus$，以及一个从$C$ 到 $V$ 之间的双射 $f$，使得对于任意满足 $a, b \in V$ 且 $a+b \in V$ 的数对 $a,b$ 都有 $f^{-1}(a) \oplus f^{-1}(b) = f^{-1}(a+b)。$</p>
</blockquote>
<p>现在对上面的数学语言描述做出一定解释：</p>
<ul>
<li><p>首先，之所以要求 $V$ 同时包含 0和正负数 是出于实用起见，毕竟表示自然数的话原码就已经够用了，要设计新的编码方案就是为了解决负数的表示问题。</p>
</li>
<li><p>其次，之所以要求 $V$ 的基数为 $2^n$，为的就是满足 $f$ 为双射的基本条件，而要求双射则是因为我们既不想浪费任何一个码点又不想有两个码点同时表示同一个值。(这样就解决的了第一个需求)</p>
</li>
<li><p>然后，运算 $\oplus$ 实际上代表的就是那个用于同时实现加减法的电路的所做的运算。之所以要求它具有封闭性是因为机器数只有有限的数位，只能表示有限的值；之所以要求它具有结合律和交换律是为了能用它来模拟整数加法，故需要满足整数加法所具有的性质。(模拟整数加法而不是整数减法是因为在数学分析中由自然数集扩展到整数集时就是用的“加上相反数”来定义减法的)</p>
</li>
<li><p>最后，之所以要求 映射$f$ 拥有那个“类似同构”的性质(简介起见，下文都将这样称呼这个性质)，则是为了通过这样来确定 $C$ 上的 运算$\oplus$ 确实可以模拟整数集上的加法，而因为整数加法正如上一点中的括号部分所述，已经通过引入相反数或者说加法逆元这个概念同时实现了加法和减法的功能，故 $\oplus$ 就可以说也同时实现了加减法。举例来说的话,比如在真正的现有补码系统中2的编码为<code>0000 0010</code>，-1的编码为<code>1111 1111</code>，1的编码为<code>0000 0001</code>的，而 $\oplus$ 被定义为了模 $2^n$ 加法，那么 $f^{-1}(2) + f^{-1}(-1) = (0000 0010 + 1111 1111) \mod 2^n = 0000 0001 = f^{-1}(2+(-1)) = f^{-1}(1)$，即两个整数的编码经过 运算$\oplus$ 处理后得到的新的编码应该等于这两个整数的和对应的编码。<del>这一点因为 $V$ 上的加法不封闭构不成一个代数，故不是真正的同构，总感觉还不太能令人信服的样子….</del></p>
</li>
</ul>
<p>因此，现在我们需要做的，就是明确好 运算$\oplus$ 和 映射$f$ 到底是什么了，只要它们满足以上描述的要求，这样就定义好了一套符合我们需求的编码系统。</p>
<h3 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h3><p>考虑到 运算$\oplus$ 需要满足的那一堆属性恰好都被我们非常熟悉也非常适合只有n位的机器数的 模$2^n$加法 所满足，因此我们可以尝试以它作为 运算$\oplus$ 并试着找出一个满足剩下的要求的 映射$f$ 来。(这里算是数学直觉加上进一步测试？)</p>
<p>考虑到实际需求，我们希望所表示的正数的范围是从1开始递增的某段连续范围，同理，所希望表示的负数范围也是从-1开始递减的某段连续范围。从这里可以看出0和1都将会被收入 $V$ 中，而其余的正数的编码其实都可以由1的编码再加上“类似同构”的性质一一得出，如 $f^{-1}(2)=f^{-1}(1) \oplus f^{-1}(1), f^{-1}(3)=f^{-1}(2) \oplus f^{-1}(1), …$而-1的编码也可以由$f^{-1}(0)=f^{-1}(1) \oplus f^{-1}(1)$得出，再然后其余的负数的编码也可以由-1的编码按类似的方法得出。于是，可以说，我们只需要指定0和1的编码各是多少就可以了。<del>实际上用于构建自然数集的Peano公理中最初也只定义了0和后缀这两个概念，然后再通过数学归纳原理把剩下的数逐个纳入到自然数集中。</del></p>
<p>一个很常见也很直观的想法就是把0的编码设为<code>0000 0000</code>，把1的编码设为<code>0000 0001</code>(又是一个直觉)，然后-1的编码根据“类似同构”性质可得出是<code>1111 1111</code>，然后我们就可以按上一段所述的方法一样不断把其余的数的编码推断出来。</p>
<p>经过观察可得知正数的编码是从<code>0000 0001</code>开始随着所表示的值递增而递增，而负数的编码是从<code>1111 1111</code>开始随着所表示的值的递减而递减，现在的问题在于如何给这两个会相遇的数列划分一个边界。为了对齐起见，我们让它们在<code>0111 1111</code>和<code>1000 0000</code>之间划分开来，使得非负数和负数的数量一样多，同时也方便我们通过最高位的0/1来判断是不是负数。故最后我们会得出这样的一个映射：</p>
<script type="math/tex; mode=display">
f^{-1}(x) = 
    \begin{cases}
        x & 0 \le x \le 2^{n-1}-1 \\
        2^n+x & -2^{n-1} \le x < 0
    \end{cases}</script><script type="math/tex; mode=display">即f^{-1}(x)=(2^n+x) \mod 2^n, (-2^{n-1} \le x \le 2^{n-1}-1)</script><p>最后，我们只需要验证这个映射是否满足“类似同构”性质即可：</p>
<p>对于 $\forall a,b \in V 且a+b \in V$，有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f^{-1}(a) \oplus f^{-1}(b)
& = (((2^n+a) \mod 2^n) + ((2^n+b) \mod 2^n)) \mod 2^n \\
& = (2*2^n + (a + b)) \mod 2^n \\
& = (a + b) \mod 2^n \\
& = (2^n + (a + b)) \mod 2^n \\
& = f^{-1}(a+b)
\end{aligned}</script><p>由此，我们就得出了这样一套满足了我们的需求的编码方案。</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>如果仅仅考虑加减法的话，按照上面的思考框架，得出另一套和现有的补码不一样但也满足需求的编码方案似乎也是可行的。<del>虽说我也没试过也没证明过就是了。</del></p>
<p>按照维基百科的描述：</p>
<blockquote>
<p>Compared to other systems for representing signed numbers (e.g., ones’ complement), two’s complement has the advantage that the fundamental arithmetic operations of <strong>addition</strong>, <strong>subtraction</strong>, and <strong>multiplication</strong> are identical to those for unsigned binary numbers (as long as the inputs are represented in the same number of bits as the output, and any overflow beyond those bits is discarded from the result).</p>
</blockquote>
<p>似乎补码的设计者们在设计时还额外考虑到了乘法的问题？如果引入乘法之后是不是上面描述的思考框架里的很多靠直觉和测试的部分就能够被确定下来了呢？还是说这套框架会被推翻呢，这个就等以后有空再思考吧。(逃</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>设计反思</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>抽象代数</tag>
        <tag>补码</tag>
      </tags>
  </entry>
  <entry>
    <title>基于OpenCV的简单几何形状识别</title>
    <url>/2021/01/24/%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E7%AE%80%E5%8D%95%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是这学期的一个大作业，要求能做到识别出图像中的矩形、三角形、以及圆形，虽然网上已经有了很多相似的解决方案，但因为我实现之后发现在我自己瞎画出来的图像上识别出来的效果都稍有瑕疵，故决定还是写一篇文章出来分享一下自己改进这些瑕疵的思路。</p>
<h2 id="互联网上已有的解决方案"><a href="#互联网上已有的解决方案" class="headerlink" title="互联网上已有的解决方案"></a>互联网上已有的解决方案</h2><p>在互联网上稍加搜索，你就可以找到很多篇有关简单几何形状识别这一内容的博客，它们的解决方案大多都是沿着同一个思路：对于圆，使用 <code>OpenCV</code> 自带的 <code>HoughCircles</code> 函数进行识别；对于三角形、矩形等多边形，则使用 <code>findConours</code> 函数先找出图像中的轮廓，再使用 <code>approxPolyDP</code> 对轮廓使用多边形进行逼近，最后根据逼近所得出的多边形的顶点数来决定其属于哪类多边形，然后再做进一步的工作，如直角的检测等。</p>
<p>我的解决方案也大致是沿着上述思路进行检测，但是加入了一些在上述步骤检测出来后的改进。</p>
<p>当然，也有的网友选择了用检测多边形的思路来检测圆（判断逼近得到的多边形顶点数是否大于一个指定的值，如10），但这在检测规模较小的图像时效果并不是那么好，故我还是沿用了上面提到的思路。</p>
<h2 id="出现的问题与解决的思路"><a href="#出现的问题与解决的思路" class="headerlink" title="出现的问题与解决的思路"></a>出现的问题与解决的思路</h2><h3 id="问题1：多边形的重复"><a href="#问题1：多边形的重复" class="headerlink" title="问题1：多边形的重复"></a>问题1：多边形的重复</h3><p>对于如下所示的图像，检测出来的结果中，三角形和矩形的数量都翻了一倍：</p>
<p><img src=".\original0.png" alt="original0.png"></p>
<p><img src=".\count_before.png" alt="count_before.png"></p>
<p>首先想到的原因，当然就是我的程序把不是矩形/三角形的形状也当成了矩形/三角形了。然而，若把识别到的矩形和三角形在原图中标识出来的话，却发现程序并没有出现这样的错误：</p>
<p><img src=".\triangles0.png" alt="triangles0.png"></p>
<p><img src=".\rectangles0.png" alt="rectangles0.png"></p>
<p>于是决定输出中间结果，即所有通过 <code>findContours</code> 与 <code>approxPloyDP</code> 找到的多边形，以进一步研究到底是怎么回事（下面只列举其中的两个）：</p>
<p><img src=".\approx3.png" alt="approx3.png"></p>
<p><img src=".\approx4.png" alt="approx4.png"></p>
<p><img src=".\approx3_and_4_info.png" alt="approx3_and_4_info.png"></p>
<p>通过观察可发现，每一个找到的多边形都被重复了两次，它们的顶点仅仅是相差一点点而已。</p>
<h3 id="问题1-解决方案"><a href="#问题1-解决方案" class="headerlink" title="问题1-解决方案"></a>问题1-解决方案</h3><p>既然出现了重复，那我们第一反应当然是要去去重，问题在于如何去重？</p>
<p>在互联网上检索了一番后，我发现 <code>OpenCV</code> 提供了一个用于图像识别的函数 <code>matchShapes</code>，它可以计算出两个轮廓的相似度，而且对于经过旋转及缩放后的图案也会判定为相似。</p>
<p>有了这一神器，思路就变得很清晰了：首先判断两个轮廓的中心是否过分相近，再通过 <code>matchShapes</code> 函数判断是否相似，最后检查两个轮廓的面积是否相差不大（因为 <code>matchShapes</code> 函数对于缩放后的图案也会检测为相似）。</p>
<p>相应代码贴见文末完整代码中的 <code>filterRepeatedContours</code> 函数。</p>
<h3 id="问题2：顶点的重复"><a href="#问题2：顶点的重复" class="headerlink" title="问题2：顶点的重复"></a>问题2：顶点的重复</h3><p>在对下图进行测试时，我发现灰色的三角形无法被检测出来：</p>
<p><img src=".\original1.png" alt="original1.png"></p>
<p><img src=".\triangles1.png" alt="triangles1.png"></p>
<p>继续输出中间结果以进行检查：</p>
<p><img src=".\approx9.png" alt="approx9.png"></p>
<p><img src=".\approx9_info.png" alt="approx9_info.png"></p>
<p>可以发现，程序把三个顶点都算了两次（虽然位置略有不同），所以逼近得到的就不是三角形，而是六边形了。</p>
<h3 id="问题2-解决方案"><a href="#问题2-解决方案" class="headerlink" title="问题2-解决方案"></a>问题2-解决方案</h3><p>既然出现了重复那当然也是需要去重了。此处的去重相比起前面对整个轮廓进行去重来说就简单了很多，这里我采用了两个思路来进行去重：</p>
<ul>
<li>和已有点距离过近的点属于重复点</li>
<li>和相邻两个点间夹角大于一定角度的点属于重复点</li>
</ul>
<p>相应代码贴见文末完整代码中的 <code>filterContourVertices</code> 函数。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>代码中抽象出了 <code>PolygonContainer</code> 这一个类用于存储特定类型的多边形以及相应的特判，同时也方便了后续的对于其他类型的多边形检测的扩展。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cv2 <span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolygonContainer</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;存储检测到的特定类型的多边形的容器。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        name (str): 该容器存储的多边形的类型名称。</span></span><br><span class="line"><span class="string">        vertex_count (int): 该多边形类型的顶点数需满足的条件，若为0则代表任意值。</span></span><br><span class="line"><span class="string">        check (func(contour, approx) -&gt; bool): 该多边形类型的特判函数。</span></span><br><span class="line"><span class="string">        contours (list): 检测到的该类型的多边形的轮廓的列表。</span></span><br><span class="line"><span class="string">        centroids (list): 检测到的该类型的多边形的轮廓中心的列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, vertex_count, check</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;PolygonContainer类的初始化函数，各参数含义与类注释中一致。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.vertex_count = vertex_count</span><br><span class="line">        self.check = check</span><br><span class="line">        self.contours = []</span><br><span class="line">        self.centroids = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showPolygonContours</span>(<span class="params">title, img, contours, centroids</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;在img上绘制多边形并显示。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        title (str): 显示窗口的标题。</span></span><br><span class="line"><span class="string">        img (np.ndarray): 待绘制多边形的图像。</span></span><br><span class="line"><span class="string">        contours (list): 多边形的轮廓列表。</span></span><br><span class="line"><span class="string">        centroids (list): 多边形的轮廓中心列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 在img上描绘出contours和centroids所指定的多边形，并进行显示</span></span><br><span class="line">    img_temp = np.copy(img)</span><br><span class="line">    cv2.drawContours(img_temp, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> mc <span class="keyword">in</span> centroids:</span><br><span class="line">        cv2.circle(img_temp, tuple(mc), <span class="number">2</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5</span>)</span><br><span class="line">    cv2.namedWindow(title, cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)</span><br><span class="line">    cv2.imshow(title, img_temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">denoise</span>(<span class="params">gray, method</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;灰度图的去噪。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        gray (np.ndarray): 待去噪的灰度图。</span></span><br><span class="line"><span class="string">        method (str): 去噪所使用的方法名。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        blurred: 去噪后得到的图像。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;MedianBlur&quot;</span>:</span><br><span class="line">        blurred = cv2.medianBlur(gray, <span class="number">5</span>)</span><br><span class="line">        cv2.namedWindow(<span class="string">&quot;MedianBlur&quot;</span>, cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)</span><br><span class="line">        cv2.imshow(<span class="string">&quot;MedianBlur&quot;</span>, blurred)</span><br><span class="line">        <span class="keyword">return</span> blurred</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;GuassBlur&quot;</span>:</span><br><span class="line">        blurred = cv2.GaussianBlur(gray, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">        cv2.namedWindow(<span class="string">&quot;GuassBlur&quot;</span>, cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)</span><br><span class="line">        cv2.imshow(<span class="string">&quot;GuassBlur&quot;</span>, blurred)</span><br><span class="line">        <span class="keyword">return</span> blurred</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;No such denoise method!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> np.copy(gray)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarize</span>(<span class="params">gray, method</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;灰度图的二值化。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        gray (np.ndarray): 待二值化的灰度图。</span></span><br><span class="line"><span class="string">        method (str): 二值化所使用的方法名。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        thresh: 二值化后得到的图像。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&quot;AdaptiveThreshold&quot;</span>:</span><br><span class="line">        thresh = cv2.adaptiveThreshold(gray, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        cv2.namedWindow(<span class="string">&quot;AdaptiveThreshold&quot;</span>, cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)</span><br><span class="line">        cv2.imshow(<span class="string">&quot;AdaptiveThreshold&quot;</span>, thresh)</span><br><span class="line">        <span class="keyword">return</span> thresh</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">&quot;Canny&quot;</span>:</span><br><span class="line">        thresh = cv2.Canny(gray, <span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line">        cv2.namedWindow(<span class="string">&quot;Canny&quot;</span>, cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)</span><br><span class="line">        cv2.imshow(<span class="string">&quot;Canny&quot;</span>, thresh)</span><br><span class="line">        <span class="keyword">return</span> thresh</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;No such binarize method!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> np.copy(gray)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rectangleCheck</span>(<span class="params">contour, approx</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;矩形特判函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        contour (np.ndarray): 待判定的轮廓。</span></span><br><span class="line"><span class="string">        approx (np.ndarray): 待判定的轮廓的多边形逼近。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        bool: 表示contour与approx是否表示一个矩形。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算轮廓面积</span></span><br><span class="line">    contour_area = cv2.contourArea(contour)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算最小包围矩形面积</span></span><br><span class="line">    rect = cv2.minAreaRect(contour)</span><br><span class="line">    box = cv2.boxPoints(rect)</span><br><span class="line">    box = np.int0(box)</span><br><span class="line">    box_area = cv2.contourArea(box)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若多边形逼近面积与最小包围矩形面积相差过大，则说明不是矩形</span></span><br><span class="line">    <span class="keyword">if</span> math.fabs(contour_area-box_area)/contour_area &gt; <span class="number">0.05</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 若角度与90度偏差超过一定范围，则说明不是矩形</span></span><br><span class="line">    <span class="keyword">for</span> vid <span class="keyword">in</span> range(<span class="number">0</span>, len(approx)):</span><br><span class="line">        vec_a = approx[vid<span class="number">-1</span>][<span class="number">0</span>] - approx[vid][<span class="number">0</span>]</span><br><span class="line">        vec_b = approx[(vid+<span class="number">1</span>) % len(approx)][<span class="number">0</span>] - approx[vid][<span class="number">0</span>]</span><br><span class="line">        norm_a = np.linalg.norm(vec_a)</span><br><span class="line">        norm_b = np.linalg.norm(vec_b)</span><br><span class="line">        <span class="comment"># 判断当前角度与90度偏差是否超过10度</span></span><br><span class="line">        cos = np.inner(vec_a, vec_b) / (norm_a*norm_b)</span><br><span class="line">        <span class="keyword">if</span> cos &gt; math.cos((<span class="number">90</span><span class="number">-10</span>)*math.pi/<span class="number">180</span>) <span class="keyword">or</span> cos &lt; math.cos((<span class="number">90</span>+<span class="number">10</span>)*math.pi/<span class="number">180</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过矩形判定</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filterRepeatedContours</span>(<span class="params">contours, centroids</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;去除contours与cnetroids中重复的轮廓与相应的中心。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        contours (list): 待去重的轮廓的列表。</span></span><br><span class="line"><span class="string">        centroids (list): 待去重的轮廓中心的列表。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        contours: 去除重复轮廓后的轮廓列表。</span></span><br><span class="line"><span class="string">        centroids: 去除重复轮廓对应的中心后的轮廓中心列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 调试：输出所有轮廓的相关数据</span></span><br><span class="line">    <span class="comment"># for cid in range(len(contours)):</span></span><br><span class="line">    <span class="comment">#     print(&quot;Contour: %d&quot; % cid)</span></span><br><span class="line">    <span class="comment">#     print(&quot;Vertex Count: &#123;0&#125;&quot;.format(contours[cid].shape[0]))</span></span><br><span class="line">    <span class="comment">#     print(&quot;Centroid: &#123;0&#125;&quot;.format(centroids[cid]))</span></span><br><span class="line">    <span class="comment">#     print(&quot;Area: &#123;0&#125;&quot;.format(cv2.contourArea(contours[cid])))</span></span><br><span class="line">    <span class="comment">#     print()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 [1.中点距离, 2.形状相似度, 3. 面积差值] 三个条件来判断轮廓是否重复</span></span><br><span class="line">    is_valid = np.ones(len(contours), dtype=bool)</span><br><span class="line">    area = [cv2.contourArea(c) <span class="keyword">for</span> c <span class="keyword">in</span> contours]</span><br><span class="line">    <span class="keyword">for</span> cid0 <span class="keyword">in</span> range(len(contours)):</span><br><span class="line">        <span class="keyword">if</span> is_valid[cid0]:</span><br><span class="line">            area0 = area[cid0]</span><br><span class="line">            <span class="keyword">for</span> cid1 <span class="keyword">in</span> range(cid0+<span class="number">1</span>, len(contours)):</span><br><span class="line">                vec = centroids[cid0] - centroids[cid1]</span><br><span class="line">                distance = np.linalg.norm(vec)</span><br><span class="line">                area1 = area[cid1]</span><br><span class="line">                area_diff = math.fabs(area0-area1)</span><br><span class="line">                match = cv2.matchShapes(contours[cid0], contours[cid1], <span class="number">1</span>, <span class="number">0.0</span>)</span><br><span class="line">                <span class="keyword">if</span> distance &lt; <span class="number">30</span> <span class="keyword">and</span> area_diff &lt; <span class="number">1000</span> <span class="keyword">and</span> match &lt; <span class="number">0.03</span>:</span><br><span class="line">                    is_valid[cid1] = <span class="literal">False</span></span><br><span class="line">    contours = [contours[cid] <span class="keyword">for</span> cid <span class="keyword">in</span> range(len(contours)) <span class="keyword">if</span> is_valid[cid]]</span><br><span class="line">    centroids = [centroids[cid] <span class="keyword">for</span> cid <span class="keyword">in</span> range(len(centroids)) <span class="keyword">if</span> is_valid[cid]]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回筛选过后的轮廓及其中心</span></span><br><span class="line">    <span class="keyword">return</span> contours, centroids</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filterContourVertices</span>(<span class="params">contour</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;去除轮廓contour中重复的顶点。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        contour (np.ndarray): 待去除重复顶点的轮廓。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        contour: 去除重复顶点后的轮廓。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 删除与已有顶点过近的顶点</span></span><br><span class="line">    is_valid = np.ones(contour.shape[<span class="number">0</span>], dtype=bool)</span><br><span class="line">    <span class="keyword">for</span> vid0 <span class="keyword">in</span> range(<span class="number">0</span>, len(contour)):</span><br><span class="line">        <span class="keyword">if</span> is_valid[vid0]:</span><br><span class="line">            <span class="keyword">for</span> vid1 <span class="keyword">in</span> range(vid0+<span class="number">1</span>, len(contour)):</span><br><span class="line">                vec = contour[vid0] - contour[vid1]</span><br><span class="line">                distance = np.linalg.norm(vec)</span><br><span class="line">                <span class="comment"># 若此顶点与已有顶点距离小于5，则可忽略</span></span><br><span class="line">                <span class="keyword">if</span> distance &lt; <span class="number">5</span>:</span><br><span class="line">                    is_valid[vid1] = <span class="literal">False</span></span><br><span class="line">    contour = contour[is_valid, :]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 删除与相邻顶点夹角过大的顶点</span></span><br><span class="line">    is_valid = np.ones(contour.shape[<span class="number">0</span>], dtype=bool)</span><br><span class="line">    <span class="keyword">for</span> vid <span class="keyword">in</span> range(<span class="number">0</span>, len(contour)):</span><br><span class="line">        vec_a = contour[vid<span class="number">-1</span>] - contour[vid]</span><br><span class="line">        vec_b = contour[(vid+<span class="number">1</span>) % len(contour)] - contour[vid]</span><br><span class="line">        norm_a = np.linalg.norm(vec_a) </span><br><span class="line">        norm_b = np.linalg.norm(vec_b)</span><br><span class="line">        <span class="comment"># 若此顶点与相邻顶点夹角过大（大于160度），则可忽略</span></span><br><span class="line">        cos = np.inner(vec_a, vec_b) / (norm_a*norm_b)</span><br><span class="line">        <span class="keyword">if</span> cos &lt; math.cos(math.pi*<span class="number">160</span>/<span class="number">180</span>):</span><br><span class="line">            is_valid[vid] = <span class="literal">False</span></span><br><span class="line">    contour = contour[is_valid, :]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回筛选后剩下的顶点</span></span><br><span class="line">    <span class="keyword">return</span> contour</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">polygonDetect</span>(<span class="params">img, denoised, approxs, *polygonContainers</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;多边形的检测函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        img (np.ndarray): 原图。</span></span><br><span class="line"><span class="string">        denoised (np.ndarray): 去噪后的图像。</span></span><br><span class="line"><span class="string">        approxs (PolygonContainer): 存储所有多边形的容器。</span></span><br><span class="line"><span class="string">        polygonContainers (list): 存储待检测的类型的多边形的容器列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 二值化</span></span><br><span class="line">    thresh = binarize(denoised, <span class="string">&quot;Canny&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 轮廓检测</span></span><br><span class="line">    contours, _ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    img_contours = np.copy(img)</span><br><span class="line">    cv2.drawContours(img_contours, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    cv2.namedWindow(<span class="string">&quot;Contours&quot;</span>, cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;Contours&quot;</span>, img_contours)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算轮廓的质心</span></span><br><span class="line">    centroids = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> contours:</span><br><span class="line">        mu = cv2.moments(c, <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> np.isclose(mu[<span class="string">&#x27;m00&#x27;</span>], <span class="number">0</span>):</span><br><span class="line">            mc = contours[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mc = [mu[<span class="string">&#x27;m10&#x27;</span>] / mu[<span class="string">&#x27;m00&#x27;</span>], mu[<span class="string">&#x27;m01&#x27;</span>] / mu[<span class="string">&#x27;m00&#x27;</span>]]</span><br><span class="line">        mc = np.int0(mc)</span><br><span class="line">        centroids.append(mc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 去除重复的轮廓</span></span><br><span class="line">    contours, centroids = filterRepeatedContours(contours, centroids)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对轮廓进行多边形逼近并分类</span></span><br><span class="line">    <span class="keyword">for</span> cid <span class="keyword">in</span> range(<span class="number">0</span>, len(contours)):</span><br><span class="line">        <span class="comment"># 获取当前枚举的轮廓边界顶点与其质心</span></span><br><span class="line">        c = contours[cid]</span><br><span class="line">        mc = centroids[cid]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 去除过小的形状（即噪声）</span></span><br><span class="line">        <span class="keyword">if</span> cv2.contourArea(c) &lt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用多边形逼近轮廓</span></span><br><span class="line">        epsilon = <span class="number">0.02</span> * cv2.arcLength(c, <span class="literal">True</span>)</span><br><span class="line">        approx = cv2.approxPolyDP(c, epsilon, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 过滤掉的无用顶点</span></span><br><span class="line">        approx = filterContourVertices(approx)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存轮廓的顶点与质心</span></span><br><span class="line">        approxs.contours.append(approx)</span><br><span class="line">        approxs.centroids.append(mc)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调试：显示当前多边形，并输出当前多边形的数据</span></span><br><span class="line">        <span class="comment"># showPolygonContours(&quot;Approx: %d - vertex_count: %d&quot; % (cid, len(approx)), img, [approx], [mc])</span></span><br><span class="line">        <span class="comment"># print(&quot;Approx: %d&quot; % cid)</span></span><br><span class="line">        <span class="comment"># print(&quot;Vertex Count: &#123;0&#125;&quot;.format(len(approx)))</span></span><br><span class="line">        <span class="comment"># print(&quot;Centroid: &#123;0&#125;&quot;.format(mc))</span></span><br><span class="line">        <span class="comment"># print(&quot;Area: &#123;0&#125;&quot;.format(cv2.contourArea(approx)))</span></span><br><span class="line">        <span class="comment"># print(&quot;Vertices: &#123;0&#125;&quot;.format(approx))</span></span><br><span class="line">        <span class="comment"># print()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断是否为所需检测的多边形</span></span><br><span class="line">        vertex_count = len(approx)</span><br><span class="line">        <span class="keyword">for</span> container <span class="keyword">in</span> polygonContainers:</span><br><span class="line">            <span class="keyword">if</span> vertex_count == container.vertex_count <span class="keyword">and</span> container.check(c, approx):</span><br><span class="line">                container.contours.append(c)</span><br><span class="line">                container.centroids.append(mc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画出检测到的轮廓的多边形</span></span><br><span class="line">    showPolygonContours(approxs.name, img, approxs.contours, approxs.centroids)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画出检测到的所需的多边形，并输出个数</span></span><br><span class="line">    <span class="keyword">for</span> container <span class="keyword">in</span> polygonContainers:</span><br><span class="line">        showPolygonContours(container.name, img, container.contours, container.centroids)</span><br><span class="line">        print(<span class="string">&quot;&#123;0&#125; Count: &#123;1&#125;&quot;</span>.format(container.name, len(container.centroids)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circleDetect</span>(<span class="params">img, denoised</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;圆的检测函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        img (np.ndarray): 原图。</span></span><br><span class="line"><span class="string">        denoised (np.ndarray): 去噪后的图像。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 用Hough变换进行圆的检测</span></span><br><span class="line">    circles = cv2.HoughCircles(denoised, cv2.HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">30</span>, param1=<span class="number">50</span>, param2=<span class="number">60</span>, minRadius=<span class="number">0</span>, maxRadius=<span class="number">0</span>)</span><br><span class="line">    circles = np.uint16(np.around(circles))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每个圆画出边界与圆心</span></span><br><span class="line">    img_circles = np.copy(img)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>, :]:</span><br><span class="line">        <span class="comment"># 画圆的边界</span></span><br><span class="line">        cv2.circle(img_circles, (i[<span class="number">0</span>], i[<span class="number">1</span>]), i[<span class="number">2</span>], (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 画圆心</span></span><br><span class="line">        cv2.circle(img_circles, (i[<span class="number">0</span>], i[<span class="number">1</span>]), <span class="number">2</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5</span>)</span><br><span class="line">    cv2.namedWindow(<span class="string">&quot;Circle&quot;</span>, cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;Circle&quot;</span>, img_circles)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出检测到的圆的个数</span></span><br><span class="line">    print(<span class="string">&quot;Circle Count: &#123;0&#125;&quot;</span>.format(circles.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shapeDetect</span>(<span class="params">img_path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;形状检测函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        img_path (str): 图像的路径。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从文件中读取图像</span></span><br><span class="line">    img = cv2.imread(img_path)</span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    cv2.namedWindow(<span class="string">&quot;Original&quot;</span>, cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;Original&quot;</span>, img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换为灰度图</span></span><br><span class="line">    cv2.namedWindow(<span class="string">&quot;Gray&quot;</span>, cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;Gray&quot;</span>, gray)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 去噪</span></span><br><span class="line">    denoised = denoise(gray, <span class="string">&quot;MedianBlur&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 三角形与矩形的检测</span></span><br><span class="line">    approxs = PolygonContainer(<span class="string">&quot;ApproxPolygons&quot;</span>, <span class="number">0</span>, <span class="keyword">lambda</span> contour, approx : <span class="literal">True</span>)</span><br><span class="line">    triangles = PolygonContainer(<span class="string">&quot;Triangle&quot;</span>, <span class="number">3</span>, <span class="keyword">lambda</span> contour, approx : <span class="literal">True</span>)</span><br><span class="line">    rectangles = PolygonContainer(<span class="string">&quot;Rectangle&quot;</span>, <span class="number">4</span>, rectangleCheck)</span><br><span class="line">    polygonDetect(img, denoised, approxs, triangles, rectangles)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 圆的检测</span></span><br><span class="line">    circleDetect(img, denoised)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 设置文件路径</span></span><br><span class="line">    img_path = <span class="string">&#x27;./images/1.png&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理文件路径指向的图像</span></span><br><span class="line">    shapeDetect(img_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按任意键后关闭所有窗口</span></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>Python</tag>
        <tag>数字图像处理</tag>
        <tag>图像识别</tag>
      </tags>
  </entry>
</search>
